# Grokking the Coding Interview Patterns for Coding Questions

## Patterns

**1. Sliding Window**
```
Given an array(or LinkedList) and asked to find or calculate something among all the contiguous subarrays(or sublists)
```

**2. Two Pointers**
```
Given sorted array(or LinkedList) and asked to find a set of elements that fulfill certain constraints. The set of elements could be a pair, a triplet or even a subarray.
```

**3. Fast and Slow Pointers**
```
This approach is useful for cyclic LinkedLists or arrays. By moving at different speeds (say, in a cyclic LinkedList), the algorithm proves that the two pointers are bound to meet. The fast pointer should catch the slow pointer once both the pointers are in a cyclic loop. 
```

**4. Merge Intervals**
```
This pattern describes an efficient technique to deal with overlapping intervals. In a lot of problems involving intervals, we either need to find overlapping intervals or merge intervals if they overlap.

Given two intervals (‘a’ and ‘b’), there will be six different ways the two intervals can relate to each other:
```
![Overlapping Intervals](https://github.com/zheng1073/Grokking-the-Coding-Interview-Patterns-for-Coding-Questions/blob/master/Pattern:%20Merge%20Intervals/6_OverlappingIntervals.PNG?raw=true)

**5. Cyclic Sort**
```
Given array containing numbers in a given range.
```

**6. In-place Reversal of a LinkedList**
```
Reverse the links between a set of nodes of a LinkedList. Often, the constraint is that we need to do this in-place, i.e., using the existing node objects and without using extra memory.R```

**7. Tree Breadth First Search**
```
Any problem involving the traversal of a tree in a level-by-level order can be efficiently solved using this approach. 

Use a Queue to keep track of all the nodes of a level before we jump onto the next level. 
```

**8. Tree Depth First Search**
```
Use recursion (or we can also use a stack for the iterative approach) to keep track of all the previous (parent) nodes while traversing.
```

**9. Two Heaps**
```
Given a set of elements such that we can divide them into two parts. 

This pattern uses two Heaps to solve these problems; A Min Heap to find the smallest element and a Max Heap to find the biggest element.
```

**10. Subsets**
```

```

**11. Modified Binary Search**
```

```

**12. Bitwise XOR**
```

```

**13. Top 'K' Elements**
```

```

**14. K-way Merge**
```

```

**15. 0/1 Knapsack (Dynamic Programming)**
```

```

**16. Topological Sort (Graph)**
```

```

**Miscellaneous**
```

```

